import java_cup.runtime.*;
import java.util.ArrayList;
import java.util.List;


/* ----------------------------------------------------------------------------
   PARSER CODE
   El objetivo es inyectar variables y métodos auxiliares dentro de la clase Parser 
   generada. Se gestiona el estado global del análisis.
   ---------------------------------------------------------------------------- */

parser code {:
    // Almacena todas las tablas de ámbitos creadas (Global, Main, Funciones, Bloques)
    public ArrayList<TablaSimbolos> reporteTablas = new ArrayList<>();

    // Almacena los errores encontrados (Léxicos y Sintácticos)
    public ArrayList<Errores> listaErrores = new ArrayList<>();

    // Variable Raíz del Árbol Sintáctico  
    public NodoCST raiz;
    
    // Punteros para el manejo de Ámbitos (Scopes)
    public TablaSimbolos tablaGlobal = new TablaSimbolos("Global", null);
    public TablaSimbolos tablaActual = tablaGlobal;
    {
    reporteTablas.add(tablaGlobal);
    }
    // Método para iniciar (llamar desde el Main antes de parse())
    public void init() {
        reporteTablas.add(tablaGlobal);
    }

    // --- MANEJO DE ÁMBITOS (SCOPES) ---
    // Simula una pila de tablas. Cuando entramos a { bajamos, cuando salimos } subimos.
    public void entrarAmbito(String nombre) {
        TablaSimbolos nuevaTabla = new TablaSimbolos(nombre, tablaActual);
        tablaActual = nuevaTabla; // El puntero baja
        reporteTablas.add(tablaActual); // La guardamos para el reporte
    }

    // Salir del ámbito actual
    public void salirAmbito() {
        if (tablaActual.padre != null) {
            tablaActual = tablaActual.padre; // El puntero sube
        }
    }
    
    public void imprimirTablas() {
        for (TablaSimbolos t : reporteTablas) {
            t.imprimir();
        }
    }

    // --- MANEJO DE ERRORES (MODO PÁNICO) ---
    // Este método se dispara cuando el parser encuentra un error pero logra
    // recuperarse usando la regla 'error'. No detiene la compilación.
    public void syntax_error(Symbol s) {
            String lexema = (s.value != null) ? s.value.toString() : "Token desconocido";
            int linea = s.right;   // En CUP, right suele guardar la línea
            int columna = s.left;  // En CUP, left suele guardar la columna

            System.out.println("(!) Error Sintactico Recuperado: " + lexema + " en linea: " + linea);

            // Guardar el error en la lista para el reporte final
            listaErrores.add(new Errores("Sintactico", "Token inesperado: " + lexema, linea, columna));
        }

    // Se dispara cuando el error es tan grave que no hay regla de recuperación posible.
    public void unrecovered_syntax_error(Symbol s) {
            String lexema = (s.value != null) ? s.value.toString() : "Token desconocido";
            int linea = s.right;
            int columna = s.left;

            System.out.println("(!) Error Sintactico IRRECUPERABLE: " + lexema + " en linea: " + linea);

            listaErrores.add(new Errores("Sintactico Fatal", "No se pudo recuperar del error", linea, columna));
        }

:}

/* Terminals (tokens returned by the scanner). */
terminal SEMI, UMINUS;
terminal ABSTRACT;

/* Palabras reservadas */
terminal FUNCTION, RETURN, GIFT, COAL, NAVIDAD;
terminal IF, ELSE, WHILE, FOR;
terminal WORLD;
terminal LOCAL;
terminal SHOW, GET;
terminal DECIDE, OF, END, BREAK;
terminal LOOP, EXIT, WHEN;

/* bloques */
terminal BLOQUE_ABI, BLOQUE_CER;

/* simbolos */
terminal PARENI, PAREND, COMA, SEMICOLON, ENDL;
terminal BRACKETI, BRACKETD;

/* operadores */
terminal PLUS, MINUS, TIMES, DIV, POW, MOD, DIVINT;
terminal IQ, IQIQ, MAQ, MEQ, MAIQ, MEIQ, DIFQ;
terminal INC, DEC;

/* operadores control */
terminal ARROW;

/* operadores logicos */
terminal AND, OR, NOT;

/* tipos */
terminal INT, FLOAT, BOOLEAN, CHAR, STRING;

/* identificadores y literales */
terminal String IDENTIFIER;
terminal Integer INTEGER_LITERAL;
terminal Float FLOAT_LITERAL;
terminal BOOL_LITERAL;
terminal CHAR_LITERAL;
terminal STRING_LITERAL;


/* 
   Casi todos los no terminales retornan un 'NodoCST'. Esto significa que cada regla
   gramatical, al ejecutarse, construye un pedacito del árbol y se lo pasa a su padre.
*/

/* NO TERMINALES */
non terminal NodoCST program, bloque;
non terminal NodoCST lista_declaracion, declaracion;
non terminal NodoCST declaracion_global;
non terminal NodoCST declaracion_funcion;
non terminal NodoCST declaracion_main;
non terminal NodoCST declaracion_local;
non terminal NodoCST asignacion_stmt;
non terminal NodoCST expresion_stmt;
non terminal NodoCST control_stmt;
non terminal NodoCST decide_stmt;
non terminal NodoCST loop_stmt;
non terminal NodoCST for_stmt;
non terminal NodoCST decide_cases;
non terminal NodoCST decide_case;
non terminal NodoCST array_dim, array_init, array_valores;
non terminal NodoCST declaracion_for;

non terminal NodoCST stmt_lista, stmt;
non terminal NodoCST expresion, expresion_logica, expresion_rel, expresion_arit;
non terminal NodoCST termino, factor;
non terminal NodoCST param_lista, param_lista_opt;
non terminal NodoCST arg_lista, arg_lista_opt;
non terminal NodoCST array_rows, array_row;

non terminal String tipo;

 

/* PRECEDENCIA */
precedence left OR;
precedence left AND;
precedence right NOT;
precedence left IQIQ, DIFQ;
precedence left MAQ, MEQ, MAIQ, MEIQ;
precedence left PLUS, MINUS;
precedence left TIMES, DIV, DIVINT, MOD;
precedence right POW, INC, DEC;
precedence right UMINUS;

// La gramática define la estructura del lenguaje y qué hacer cuando se reconoce algo.

/* PRODUCCION INICIAL */
start with program;


/* Produccion inicial */
// Conectar la lista de declaraciones con la raíz del parser.
program ::= lista_declaracion:l 
    {: 
        NodoCST n = new NodoCST("PROGRAMA");
        n.addHijo(l);
        parser.raiz = n; // Guardamos la raiz
        RESULT = n; 
    :};

// Recursividad para admitir múltiples declaraciones
lista_declaracion ::= lista_declaracion:l declaracion:d 
    {: 
        NodoCST n = new NodoCST("LISTA_DECL");
        n.addHijo(l); n.addHijo(d);
        RESULT = n; 
    :}
    | declaracion:d
    {: 
        NodoCST n = new NodoCST("LISTA_DECL");
        n.addHijo(d);
        RESULT = n; 
    :};


declaracion ::= declaracion_global:d {: RESULT = d; :} 
              | declaracion_funcion:d {: RESULT = d; :} 
              | declaracion_main:d {: RESULT = d; :};



/* Variables Globales */
/* DECLARACIÓN GLOBAL
   Insertar la variable en la Tabla de Símbolos Global.
   Crear el nodo visual del árbol con sus hijos (tipo, id, valor).
*/
declaracion_global ::= 
      WORLD tipo:t IDENTIFIER:id ENDL 
      {: 

          Parser p = (Parser)parser;
          Simbolo s = new Simbolo(id, t, "Variable Global", "Global", idleft, idright);
          p.tablaGlobal.insertar(s);
          System.out.println("Variable global detectada: " + id);
          
          NodoCST n = new NodoCST("DECL_GLOBAL");
          n.addHijo("world"); n.addHijo(new NodoCST(t)); n.addHijo(id); n.addHijo("endl");
          RESULT = n;
      :}
    | WORLD tipo:t IDENTIFIER:id IQ expresion:e ENDL 
      {: 
          // TU LOGICA EXISTENTE
          Parser p = (Parser)parser;
          Simbolo s = new Simbolo(id, t, "Variable Global", "Global", idleft, idright);
          p.tablaGlobal.insertar(s);
          System.out.println("Variable global detectada (con valor): " + id);
          
          // NUEVA LOGICA DE ARBOL
          NodoCST n = new NodoCST("DECL_GLOBAL_INIT");
          n.addHijo("world"); n.addHijo(new NodoCST(t)); n.addHijo(id); n.addHijo("="); n.addHijo(e); n.addHijo("endl");
          RESULT = n;
      :};



declaracion_main ::= 
    COAL NAVIDAD:id 
    {: 
        // TU LOGICA EXISTENTE
        Parser p = (Parser)parser;
        Simbolo s = new Simbolo("navidad", "coal", "Main", p.tablaActual.nombreAmbito, idleft, idright);
        p.tablaActual.insertar(s);
        p.entrarAmbito("Main_Navidad");
    :} 
    PARENI PAREND bloque:b
    {: 
        // TU LOGICA EXISTENTE
        ((Parser)parser).salirAmbito(); 
        
        // NUEVA LOGICA DE ARBOL
        NodoCST n = new NodoCST("MAIN");
        n.addHijo("coal"); n.addHijo("navidad"); n.addHijo("¿"); n.addHijo("?"); n.addHijo(b);
        RESULT = n;
    :};


/* 
   Declarar funciones con parámetros.
   Insertar la función en la tabla actual y crear un nuevo ámbito hijo.
   Crear el nodo "FUNCION" conteniendo su tipo, nombre y cuerpo.
*/
declaracion_funcion ::= 
    GIFT tipo:t IDENTIFIER:id 
    {: 
        Parser p = (Parser)parser;
        Simbolo s = new Simbolo(id, t, "Funcion", p.tablaActual.nombreAmbito, idleft, idright);
        p.tablaActual.insertar(s);
        p.entrarAmbito("Funcion_" + id); 
    :}
    PARENI param_lista_opt:p PAREND 
    bloque:b 
    {: 
        ((Parser)parser).salirAmbito(); 
        
        NodoCST n = new NodoCST("FUNCION");
        n.addHijo("gift"); n.addHijo(new NodoCST(t)); n.addHijo(id); n.addHijo("¿"); n.addHijo(p); n.addHijo("?"); n.addHijo(b);
        RESULT = n;
    :};


/*
   Agrupar múltiples sentencias.
   Cada bloque crea su propio ámbito (variables locales mueren al salir).
*/
bloque ::= 
    BLOQUE_ABI 
    {: Parser p = (Parser)parser; p.entrarAmbito("Bloque_" + p.tablaActual.nombreAmbito); :}
    stmt_lista:l 
    BLOQUE_CER
    {: 
        ((Parser)parser).salirAmbito(); 
        NodoCST n = new NodoCST("BLOQUE");
        n.addHijo("¡"); n.addHijo(l); n.addHijo("!");
        RESULT = n;
    :};


/* SENTENCIAS (STMT)
   Definen qué puede ir dentro de un bloque de código.
*/

stmt_lista ::= stmt_lista:l stmt:s {: NodoCST n = new NodoCST("STMT_LIST"); n.addHijo(l); n.addHijo(s); RESULT = n; :}
             | stmt:s {: NodoCST n = new NodoCST("STMT_LIST"); n.addHijo(s); RESULT = n; :};


stmt ::= declaracion_local:d {: RESULT = d; :}
       | asignacion_stmt:a   {: RESULT = a; :}
       | expresion_stmt:e    {: RESULT = e; :}
       | control_stmt:c      {: RESULT = c; :}
       | RETURN expresion:e ENDL {: NodoCST n = new NodoCST("RETURN"); n.addHijo("return"); n.addHijo(e); n.addHijo("endl"); RESULT = n; :}
       | BREAK ENDL {: NodoCST n = new NodoCST("BREAK"); n.addHijo("break"); n.addHijo("endl"); RESULT = n; :}
       | SHOW expresion:e ENDL {: NodoCST n = new NodoCST("SHOW"); n.addHijo("show"); n.addHijo(e); n.addHijo("endl"); RESULT = n; :}
       | GET IDENTIFIER:id ENDL {: NodoCST n = new NodoCST("GET"); n.addHijo("get"); n.addHijo(id); n.addHijo("endl"); RESULT = n; :}
       | error ENDL {: NodoCST n = new NodoCST("ERROR_RECUPERADO"); RESULT = n; :};


param_lista_opt ::= param_lista:l {: RESULT = l; :} | /* vacío */ {: RESULT = new NodoCST("VACIO"); :};

param_lista ::= param_lista:l COMA tipo:t IDENTIFIER:id
    {: 
        Parser p = (Parser)parser;
        Simbolo s = new Simbolo(id, t, "Parametro", p.tablaActual.nombreAmbito, idleft, idright);
        p.tablaActual.insertar(s);
        
        NodoCST n = new NodoCST("PARAMS"); n.addHijo(l); n.addHijo(","); n.addHijo(new NodoCST(t)); n.addHijo(id); RESULT = n;
    :}
    | tipo:t IDENTIFIER:id
    {: 
        Parser p = (Parser)parser;
        Simbolo s = new Simbolo(id, t, "Parametro", p.tablaActual.nombreAmbito, idleft, idright);
        p.tablaActual.insertar(s);
        
        NodoCST n = new NodoCST("PARAM"); n.addHijo(new NodoCST(t)); n.addHijo(id); RESULT = n;
    :};

arg_lista_opt ::= arg_lista:l {: RESULT = l; :} | /* vacío */ {: RESULT = new NodoCST("VACIO"); :};
arg_lista ::= arg_lista:l COMA expresion:e {: NodoCST n = new NodoCST("ARGS"); n.addHijo(l); n.addHijo(","); n.addHijo(e); RESULT = n; :} 
            | expresion:e {: RESULT = e; :};


declaracion_local ::= 
      LOCAL tipo:t IDENTIFIER:id ENDL 
      {: 
          Parser p = (Parser)parser;
          Simbolo s = new Simbolo(id, t, "Local", p.tablaActual.nombreAmbito, idleft, idright);
          p.tablaActual.insertar(s);
          
          NodoCST n = new NodoCST("DECL_LOCAL"); n.addHijo("local"); n.addHijo(new NodoCST(t)); n.addHijo(id); n.addHijo("endl"); RESULT = n;
      :}
    | LOCAL tipo:t IDENTIFIER:id IQ expresion:e ENDL
      {: 
          Parser p = (Parser)parser;
          Simbolo s = new Simbolo(id, t, "Local", p.tablaActual.nombreAmbito, idleft, idright);
          p.tablaActual.insertar(s);
          
          NodoCST n = new NodoCST("DECL_LOCAL_INIT"); n.addHijo("local"); n.addHijo(new NodoCST(t)); n.addHijo(id); n.addHijo("="); n.addHijo(e); n.addHijo("endl"); RESULT = n;
      :}
    | LOCAL tipo:t IDENTIFIER:id array_dim:d ENDL
      {:
          Parser p = (Parser)parser;
          Simbolo s = new Simbolo(id, t + "[][]", "Arreglo 2D", p.tablaActual.nombreAmbito, idleft, idright);
          p.tablaActual.insertar(s);
          
          NodoCST n = new NodoCST("DECL_ARRAY"); n.addHijo("local"); n.addHijo(new NodoCST(t)); n.addHijo(id); n.addHijo(d); n.addHijo("endl"); RESULT = n;
      :}
    | LOCAL tipo:t IDENTIFIER:id array_dim:d IQ array_init:i ENDL
      {:
          Parser p = (Parser)parser;
          Simbolo s = new Simbolo(id, t + "[][]", "Arreglo 2D", p.tablaActual.nombreAmbito, idleft, idright);
          p.tablaActual.insertar(s);
          
          NodoCST n = new NodoCST("DECL_ARRAY_INIT"); n.addHijo("local"); n.addHijo(new NodoCST(t)); n.addHijo(id); n.addHijo(d); n.addHijo("="); n.addHijo(i); n.addHijo("endl"); RESULT = n;
      :};

/*REGLAS AUXILIARES PARA ARREGLOS*/
array_dim ::= BRACKETI INTEGER_LITERAL:i1 BRACKETD BRACKETI INTEGER_LITERAL:i2 BRACKETD
    {: NodoCST n = new NodoCST("DIMENSION"); n.addHijo("["); n.addHijo(i1.toString()); n.addHijo("]"); n.addHijo("["); n.addHijo(i2.toString()); n.addHijo("]"); RESULT = n; :};

array_init ::= BLOQUE_ABI array_rows:r BLOQUE_CER {: NodoCST n = new NodoCST("ARRAY_INIT"); n.addHijo("¡"); n.addHijo(r); n.addHijo("!"); RESULT = n; :};

array_rows ::= array_rows:rs array_row:r {: NodoCST n = new NodoCST("FILAS"); n.addHijo(rs); n.addHijo(r); RESULT = n; :}
             | array_row:r {: RESULT = r; :};

array_row ::= BLOQUE_ABI array_valores:v BLOQUE_CER {: NodoCST n = new NodoCST("FILA"); n.addHijo("¡"); n.addHijo(v); n.addHijo("!"); RESULT = n; :};

array_valores ::= expresion:e {: RESULT = e; :} 
                | array_valores:v COMA expresion:e {: NodoCST n = new NodoCST("VALORES"); n.addHijo(v); n.addHijo(","); n.addHijo(e); RESULT = n; :};


asignacion_stmt ::= IDENTIFIER:id IQ expresion:e ENDL {: NodoCST n = new NodoCST("ASIGNACION"); n.addHijo(id); n.addHijo("="); n.addHijo(e); n.addHijo("endl"); RESULT = n; :};
expresion_stmt ::= expresion:e ENDL {: NodoCST n = new NodoCST("EXP_STMT"); n.addHijo(e); n.addHijo("endl"); RESULT = n; :};
control_stmt ::= decide_stmt:d {: RESULT = d; :} | loop_stmt:l {: RESULT = l; :} | for_stmt:f {: RESULT = f; :};




decide_stmt ::= DECIDE OF decide_cases:c END DECIDE ENDL {: NodoCST n = new NodoCST("DECIDE"); n.addHijo("decide of"); n.addHijo(c); n.addHijo("end decide endl"); RESULT = n; :};
decide_cases ::= decide_cases:cs decide_case:c {: NodoCST n = new NodoCST("CASES"); n.addHijo(cs); n.addHijo(c); RESULT = n; :} | decide_case:c {: RESULT = c; :};
decide_case ::= expresion:e ARROW bloque:b {: NodoCST n = new NodoCST("CASE"); n.addHijo(e); n.addHijo("->"); n.addHijo(b); RESULT = n; :}
              | ELSE ARROW bloque:b {: NodoCST n = new NodoCST("CASE_ELSE"); n.addHijo("else"); n.addHijo("->"); n.addHijo(b); RESULT = n; :};


/* --- Loops y Control --- */
loop_stmt ::= LOOP {: ((Parser)parser).entrarAmbito("Loop"); :} stmt_lista:l EXIT WHEN expresion:e ENDL END LOOP ENDL
    {: 
       ((Parser)parser).salirAmbito(); 
       NodoCST n = new NodoCST("LOOP"); n.addHijo("loop"); n.addHijo(l); n.addHijo("exit when"); n.addHijo(e); n.addHijo("end loop"); RESULT = n; 
    :};


for_stmt ::= FOR PARENI {: ((Parser)parser).entrarAmbito("For_Header"); :} declaracion_for:d expresion:e1 ENDL expresion:e2 PAREND bloque:b
    {: 
       ((Parser)parser).salirAmbito(); 
       NodoCST n = new NodoCST("FOR"); n.addHijo("for"); n.addHijo("¿"); n.addHijo(d); n.addHijo(e1); n.addHijo("endl"); n.addHijo(e2); n.addHijo("?"); n.addHijo(b); RESULT = n; 
    :};



declaracion_for ::= tipo:t IDENTIFIER:id IQ expresion:e ENDL {: NodoCST n = new NodoCST("DEC_FOR"); n.addHijo(new NodoCST(t)); n.addHijo(id); n.addHijo("="); n.addHijo(e); n.addHijo("endl"); RESULT = n; :}
                  | IDENTIFIER:id IQ expresion:e ENDL {: NodoCST n = new NodoCST("ASIG_FOR"); n.addHijo(id); n.addHijo("="); n.addHijo(e); n.addHijo("endl"); RESULT = n; :};

tipo ::= INT      {: RESULT = "int"; :}
       | FLOAT    {: RESULT = "float"; :}
       | BOOLEAN  {: RESULT = "boolean"; :}
       | CHAR     {: RESULT = "char"; :}
       | STRING   {: RESULT = "string"; :};


expresion ::= expresion_logica:e {: RESULT = e; :};

expresion_logica ::= expresion_logica:e1 AND expresion_logica:e2 {: NodoCST n = new NodoCST("AND"); n.addHijo(e1); n.addHijo("@"); n.addHijo(e2); RESULT = n; :}
                   | expresion_logica:e1 OR expresion_logica:e2 {: NodoCST n = new NodoCST("OR"); n.addHijo(e1); n.addHijo("~"); n.addHijo(e2); RESULT = n; :}
                   | NOT expresion_logica:e {: NodoCST n = new NodoCST("NOT"); n.addHijo("Σ"); n.addHijo(e); RESULT = n; :}
                   | expresion_rel:e {: RESULT = e; :};

expresion_rel ::= expresion_arit:e1 IQIQ expresion_arit:e2 {: NodoCST n = new NodoCST("EQ"); n.addHijo(e1); n.addHijo("=="); n.addHijo(e2); RESULT = n; :}
                | expresion_arit:e1 DIFQ expresion_arit:e2 {: NodoCST n = new NodoCST("NEQ"); n.addHijo(e1); n.addHijo("!="); n.addHijo(e2); RESULT = n; :}
                | expresion_arit:e1 MAQ expresion_arit:e2 {: NodoCST n = new NodoCST("GT"); n.addHijo(e1); n.addHijo(">"); n.addHijo(e2); RESULT = n; :}
                | expresion_arit:e1 MEQ expresion_arit:e2 {: NodoCST n = new NodoCST("LT"); n.addHijo(e1); n.addHijo("<"); n.addHijo(e2); RESULT = n; :}
                | expresion_arit:e1 MAIQ expresion_arit:e2 {: NodoCST n = new NodoCST("GTE"); n.addHijo(e1); n.addHijo(">="); n.addHijo(e2); RESULT = n; :}
                | expresion_arit:e1 MEIQ expresion_arit:e2 {: NodoCST n = new NodoCST("LTE"); n.addHijo(e1); n.addHijo("<="); n.addHijo(e2); RESULT = n; :}
                | expresion_arit:e {: RESULT = e; :};

expresion_arit ::= expresion_arit:e1 PLUS termino:e2 {: NodoCST n = new NodoCST("SUMA"); n.addHijo(e1); n.addHijo("+"); n.addHijo(e2); RESULT = n; :}
                 | expresion_arit:e1 MINUS termino:e2 {: NodoCST n = new NodoCST("RESTA"); n.addHijo(e1); n.addHijo("-"); n.addHijo(e2); RESULT = n; :}
                 | termino:t {: RESULT = t; :};


termino ::= termino:t TIMES factor:f {: NodoCST n = new NodoCST("MULT"); n.addHijo(t); n.addHijo("*"); n.addHijo(f); RESULT = n; :}
          | termino:t DIV factor:f {: NodoCST n = new NodoCST("DIV"); n.addHijo(t); n.addHijo("/"); n.addHijo(f); RESULT = n; :}
          | termino:t DIVINT factor:f {: NodoCST n = new NodoCST("DIVINT"); n.addHijo(t); n.addHijo("//"); n.addHijo(f); RESULT = n; :}
          | termino:t MOD factor:f {: NodoCST n = new NodoCST("MOD"); n.addHijo(t); n.addHijo("%"); n.addHijo(f); RESULT = n; :}
          | factor:f {: RESULT = f; :};

factor ::= INTEGER_LITERAL:v {: RESULT = new NodoCST(v.toString()); :}
         | FLOAT_LITERAL:v   {: RESULT = new NodoCST(v.toString()); :}
         | BOOL_LITERAL:v    {: RESULT = new NodoCST(v.toString()); :}
         | CHAR_LITERAL:v    {: RESULT = new NodoCST(v.toString()); :}
         | STRING_LITERAL:v  {: RESULT = new NodoCST(v.toString()); :}
         | IDENTIFIER:id     {: RESULT = new NodoCST(id); :}
         | IDENTIFIER:id BRACKETI expresion:e1 BRACKETD BRACKETI expresion:e2 BRACKETD {: NodoCST n = new NodoCST("ACCESO_ARRAY"); n.addHijo(id); n.addHijo("["); n.addHijo(e1); n.addHijo("]"); n.addHijo("["); n.addHijo(e2); n.addHijo("]"); RESULT = n; :}
         | IDENTIFIER:id PARENI arg_lista_opt:a PAREND {: NodoCST n = new NodoCST("LLAMADA"); n.addHijo(id); n.addHijo("("); n.addHijo(a); n.addHijo(")"); RESULT = n; :}
         | MINUS factor:f {: NodoCST n = new NodoCST("NEGACION"); n.addHijo("-"); n.addHijo(f); RESULT = n; :} %prec UMINUS
         | INC IDENTIFIER:id {: NodoCST n = new NodoCST("INC"); n.addHijo("++"); n.addHijo(id); RESULT = n; :}
         | DEC IDENTIFIER:id {: NodoCST n = new NodoCST("DEC"); n.addHijo("--"); n.addHijo(id); RESULT = n; :}
         | PARENI expresion:e PAREND {: NodoCST n = new NodoCST("AGRUPACION"); n.addHijo("("); n.addHijo(e); n.addHijo(")"); RESULT = n; :};